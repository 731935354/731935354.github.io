---
title: MIT算法导论笔记(6):线性时间排序
tags:
  - 算法
categories: 技术
date: 2017-10-24 13:00:00
mathjax: true
---

# 排序算法能有多快？ 
 
这取决与你使用的计算模型里哪些操作是被允许的。模型简单来说就是你可以对元素进行的操作。  

排序算法回顾

| 排序算法 | 时间复杂度 |
| :------ |:------|
| 快速排序 | 随机化快速排序平均情况$\Theta(n\lg{n})$ |
| 堆排序 | 永远是$\Theta(n\lg{n})$ |
| 归并排序 | $\Theta(n\lg{n})$ |
| 插入排序 | $\Theta(n^2)$ |

以上四个排序算法都有一个共同点：只能对两个元素进行比较。这就是四个算法共用的模型。在这个模型中，最快的速度为$\Theta(n\lg{n})$

思考：排序算法能比$\Theta(n\lg{n})$更快吗？

<!-- more -->

## 比较排序模型
在比较排序模型中，只能通过比较来决定元素的相对顺序。

## 决策树
决策树是除了比较模型之外，另一种规定你可以在算法中进行哪些操作的模型，但它比比较模型适用范围更广。  
### 引入
例：对【$a_1, a_2, a_3$】进行排序

![决策树](http://owruh8822.bkt.clouddn.com/mit_6_decision_tree_1.png)

* 每个节点表示对两个元素进行比较
* 如果左边节点小于右边节点，则进入左分支，否则进入右分支
* 叶节点表示最终的排序方式

例：对【9, 4, 6】进行排序

![决策树实例](http://owruh8822.bkt.clouddn.com/mit_6_decision_tree_2.png)

### 通用模型
待排序数组：【$a_1, a_2, \cdots , a_n$】

* 每个内部节点都有形如【i:j】的标记，$i,j \in \{1,2,\cdots,n\}$
	+ 表示我们要比较$a_i$和$a_j$的大小
	+ 左子树对应$a_i \leqslant a_j$的情况
	+ 右子树对应$a_i > a_j$的情况
* 每个叶节点代表一个排序$<\pi(1),\pi(2),\cdots,\pi(n)>$，使得$a\pi(1) \leqslant a\pi(2) \leqslant \cdots \leqslant a\pi(n)$

### 决策树下的排序算法
* 决策树模型和比较模型相差不大，给定一个比较排序算法，例如快速排序，堆排序，归并排序或者插入排序，可以将其转换成决策树模型的方式，这是算法的一种图形表示。
* 决策树模型不是表达算法的常用方式
	+ 决策树的大小随n改变而改变（不具有一般性）

### 比较模型的决策树形式
* 为每一个n值绘制一棵决策树
* 当进行比较时，把决策树树分成两个分支
* 决策树列举了比较的所有可能的结果  
* 运行时间（比较的次数） = 决策树上路径的长度
* 最坏情况运行时间 = 树的深度（决策树上最长路径的长度）

叶节点的数量：n!（需要包括所有可能的排序方式）  
由于决策树很大，所以用它来描述算法不是很方便，相比之下，伪代码更加简洁，其长度不随n改变。

### 决策树排序下界
任何对n个元素进行排序的决策树，其高度为$\Omega(n\lg{n})$

证明：

* 决策树叶节点的数量一定$\geqslant n!$
* 假设树的高度为h，叶子个数$\leqslant 2^h$
* $\Rightarrow n! \leqslant 2^h$
* $\Rightarrow h \geqslant \lg{n!}$
* 根据斯特林公式，$n! \approx \sqrt{2 \pi n}(\frac{n}{e})^n$，选取公式中的最高阶因子
* $h \geqslant \lg{(\frac{n}{e})^n} = n\lg{(\frac{n}{e})} = n(\lg{n} - \lg{e}) = \Omega(n\lg{n})$

以上证明了所有的排序算法对应的决策树的深度至少是$n\lg{n}$

### 基于比较的排序算法的下界
归并排序和堆排序算法是渐进最优的。随机化快速排序也是渐近最优的。

# 线性时间排序
## 计数排序
### 描述
输入：$A[1,2,\cdots,n]，A[i] \in \{1,2,\cdots,k\}$  
输出：$B[1,2,\cdots,n]$，数组A排序之后的序列  
辅助存储序列：$C[1,2,\cdots,k]$
限制：A数组中所有元素都为整数
### 伪代码
```
for i ← 1 to k // 初始化C数组
	do C[i] ← 0
for j ← 1 to n // 用C记录A数组中数值出现的频率
	do C[A[j]] ← C[A[j]] + 1 // C[i] = |{key=i}|
for i ← 2 to k // 对C进行前缀加和
	do C[i] ← C[i] + C[i-1]
for j ← n downto 1 // 将数值分配到正确的位置
	do B[C[A[j]]] ← A[j]
	   C[A[j]] ← C[A[j]] - 1
```
解析：

* C[i]用来记录某些数值出现的频率
* 第一个for循环，将C数组中所有元素初始化为0
* 第二个for循环，记录数组A中的元素出现的频率，C[i]表示数值i出现的频率
* 第三个for循环，对数组C的前缀做加法，循环结束后，C[i]表示$\leqslant i$的数值出现的频率
* 第四个for循环，分配过程

### 举例
待排序数组：A = [4, 1, 3, 4, 3]  
算法运行过程：

* 【第一个for循环】初始化C：C = [0, 0, 0, 0]（数组A中最大元素为4，所以数组C长度为4）
* 【第二个for循环】用C记录A数组中数值出现的频率：
	+ 扫描A数组
		+ A[1] = 4，则C[4] = C[4] + 1，C = [0, 0, 0, 1]
		+ A[2] = 1，则C[1] = C[1] + 1，C = [1, 0, 0, 1]
		+ 以下同理，最终C = [1, 0, 2, 2]
* 【第三个for循环】对C进行前缀加和，C' = [1, 0, 3, 5]
* 【第四个for循环】分配过程
	+ 反向扫描A数组
		+ 取出待分配的数值A[5] = 3，去C'数组找第3个元素，C'[3] = 3，表明应将待分配数值放到B的第3个位置  
		  B = [未知, 未知, 3, 未知, 未知]  
		  更新C'数组，C'[3] = C'[3] - 1  
		  C' = [1, 0, 2, 5]
		+ 取出待分配的数值A[4] = 4，去C数组找第4个元素，C'[4] = 5，表明应将待分配数值放到B的第5个位置  
		  B = [未知, 未知, 3, 未知, 5]  
		  更新C'数组，C'[4] = C'[4] - 1  
		  C' = [1, 0, 2, 4]
		+ 以下同理，直到A[1]分配完毕

C'数组的含义：  
本例中，C'= [1, 0, 3, 5]，实际意义为

* 数值【1】应放在数组B的[1]位置
* 数值【3】应放在数组B的[2-3]位置，
* 数值【4】应放在数组B的[4-5]位置

### 运行时间
* for循环中的操作都是$O(1)$的，因此只需要关注for循环了多少次
* 【第一个for循环】$O(k)$
* 【第二个for循环】$O(n)$
* 【第三个for循环】$O(k)$
* 【第四个for循环】$O(n)$

总体运行时间：$T(n)=O(k+n)$

* 如果$k=O(n)$，则$T(n)=O(n)$

因此当数组A中数值范围较小时，算法的效率较高。
### 性质
计数排序是稳定的。  
排序的稳定性：如果一个排序算法可以保证相等的元素相对顺序不变，则这个排序算法是稳定的。

## 基数排序
### 历史
基数排序是在1890年左右由Herman Hollerith提出的，他发明了最早版本的打孔卡片，打孔卡片被设计成网格状，用以记录二进制数据。。  
在1890年以前，美国人口普查是一项艰巨的任务，法律规定必须每10年调查一次。1880年的人口普查耗费了7年半的时间，很多人预测随着人口增长，1890年的人口普查可能会耗费10年以上的时间，因此需要一个更高效的数据统计方案。Herman Hollerith打算建造一台可以统计数据的机器，首先将人口相关信息，如性别，年龄等编码成二进制，记录在打孔卡片上，（可以简单认为一张打孔卡片表示一个数，从左到右，每一列代表这个数的高位至低位）然后利用机器将卡片排序，以便后续的统计。

* 最初的想法：首先对数字的高位进行排序
	+ 问题：当时并没有电子计算机，所以排序过程需要人工参与，具体做法是，首先以卡片最高位（最左侧一列）被打孔的位置将卡片分到不同的“桶”中，然后再以左侧第二列分类，以此类推，很快“桶”的数量会变得非常多。

* Herman Hollerith的想法：首先对数字的低位进行排序。必须使用稳定的排序算法。

Herman Hollerith在1911年发明了这个制表机，并创办了一家公司，但不久就因资金周转不灵陷入困境，被另一家CTR公司兼并。1924年，CTR公司更名为“国际商业机器公司”，英文缩写“IBM”，专门生产打孔机、制表机一类产品。
### 举例

![基数排序](http://owruh8822.bkt.clouddn.com/mit_6_radix_sort.png)

### 正确性证明

* 归纳假设：t-1位已经有序
* 对第t位排序
	+ 如果两个数的第t位相同，基于稳定性原则，两个数的相对顺序不变。根据归纳假设，两个数仍是有序的。
	+ 如果两个数的第t位不同，根据第t位进行排序，最终两个数有序。

### 运行时间分析
* 对每一位上的数字采用计数排序【$O(k+n)$】
* 假设有n个整数，每个整数都用b位二进制数表示（范围：$0 \cdots 2^b-1$）
* 把每个整数拆分为$\frac{b}{r}$位数字，每个数字为r位【即基于$2^r$进制表示这个数】
* $\frac{b}{r}$是算法将要循环的轮数，$2^r$是基数的最大值，也是计数排序中的k值

$$
\begin{aligned}
T(n) & = 循环的轮数 * 每一轮的运行时间 \\
 	  & = O(\frac{b}{r} \cdot (n+k)) \\
 	  & = O(\frac{b}{r} \cdot (n+2^r)) \\
\end{aligned}$$

其中r可以任意选择，以使得算法运行时间最短

* 方案1：对函数$f(r)=\frac{b}{r} \cdot (n+2^r)$求导，求解导数为0时对应的r，$\Rightarrow r=\lg{n}$
* 方案2：观察$f(r)=\frac{b}{r} \cdot (n+2^r) = \frac{bn}{r} + \frac{b2^r}{r}$
	+ $\frac{bn}{r}$希望r更大
	+ $\frac{b2^r}{r}$希望r更小
	+ 在$n \geqslant 2^r$成立的情况下（我们要让n决定多项式的大小），选择最大的r  
	  $\Rightarrow r=\lg{n}$

带入$r=\lg{n}$，$T(n)=O(\frac{b}{\lg{n}} \cdot (n + n)) = O(\frac{bn}{\lg{n}})$

如果数字范围是$0 \cdots 2^b-1$($0 \cdots n^d-1$)  

则$T(n)=O(dn)$

如果$d=O(1)$，则整体时间复杂度是线性的，即$T(n)=O(n)$



# 附录
## 排序算法的稳定性

| 排序算法 | 是否稳定 |
| :------ |:------|
| 基数排序 | 是 |
| 冒泡排序 | 是 |
| 插入排序 | 是 |
| 归并排序 | 是 |
| 快速排序 | 否 |
| 堆排序 | 否 |
| 希尔排序 | 否 |
| 直接选择排序 | 否 |

## 目前已知的最优排序算法
如果

* 对任意整数排序
* 每个数都是1个字长
* 可以在常数时间内操作一个字

目前最佳算法（是一个随机算法）的期望运行时间为$O(n\sqrt{\lg{(\lg{n})}})$

还有一种最坏情况为$O(n\lg{(\lg{n})})$的算法




